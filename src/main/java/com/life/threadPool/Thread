线程有两种创建方式:1、实现runable接口，实现run方法，2、继承Thread重写run方法，3、实例化Thread通过start方法触发
这里run和start的区别在于是否创建新的线程，run是在当前线程执行run方法，start是新起一个线程，最后执行run方法。
初始状态：通过new关键字创建，但没有执行run或者start方法。
就绪状态：等待cpu时间片执行时的状态。
运行状态：到达cpu时间片，开始执行run方法。
阻塞状态：进入同步锁，锁没有释放。
等待状态：包括等待和超时等待，通过sleep()进入超时等待状态，此时cpu时间片不被回收
终止状态：run方法执行完了后的状态。


用线程池的好处：
1、降低资源耗时，2、提高响应速度，3、合理管理线程资源

线程池的创建和调度是分开的，创建是通过ThredPoolExecute，有七个参数分别是核心线程池，最大线程池，活跃时间，单位，阻塞队列，线程工厂，拒绝策略
由execute方法为统一入口调度，调度逻辑为：
1、如果核心线程数充足，直接创建线程执行提交任务，反之，判断阻塞队列
2、如果阻塞队列数量充足，直接创建线程提交任务，反之，判断最大线程池
3、如果最大线程池数量充足，直接创建提交任务，反之，触发拒绝策略

线程池中的活跃时间：这个时间是针对最大线程池数量设定的，如果核心线程池和阻塞队列都不足的情况下，由最大线程池创建线程，这个线程的活跃时间就是keepAliveTime。
比如newCachedThreadPool，活跃时间1分钟，保证了线程池的伸缩性

线程池拒绝策略：当配置的线程池数量都不足以满足当前的高并发场景时候的降级策略，可以通过实现RejectExecuteHander来自定义；
jdk已经实现了四种
1、直接抛出一个拒绝异常，默认
2、看执行程序是否关闭，如果关闭，丢弃当前提交线程，没有关闭就执行
3、不做任何事情，丢弃当前的线程
4、出队，然后处理当前的

线程池的阻塞队列：
fix-linkedBlockQueue 无界队列
cache-syncBlockQueue 不存储元素的队列


Object中的wait()和notify()方法：
阻塞当前线程，进入等待队列，等待其他线程notify/notifyAll唤醒,object属于java的顶级类，任何线程都是object的子类，因此将wait、notify放在顶级类中最好
相反的sleep并不会释放锁，在sleep操作后直接有cpu调度其行为属于当前线程私有行为，因此sleep在Thread中


